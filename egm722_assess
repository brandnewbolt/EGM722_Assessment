# this lets us use the figures interactively
%matplotlib notebook

#import modules (straight from wk2&3 so far) - do i need more?
import pandas as pd
import geopandas as gpd
import geopandas as gpd
import matplotlib.pyplot as plt
from cartopy.feature import ShapelyFeature
import cartopy.crs as ccrs
import matplotlib.patches as mpatches
import matplotlib.lines as mlines

#enable interactive plotting
plt.ion()

#function generates handles to create legend for polygon map features (practical 2); defines handle characteristics
#which require input when function is called, calls colours to be selected from and then assigns characteristics to the legend entries (as patches)
def generate_handles(labels, colors, edge='k', alpha=1):
    lc = len(colors)  # get the length of the color list
    handles = []
    for i in range(len(labels)):
        handles.append(mpatches.Rectangle((0, 0), 1, 1, facecolor=colors[i % lc], edgecolor=edge, alpha=alpha))
    return handles

# function creates a scale bar of length 20 km in the upper right corner of the map (practical 2)
# adapted this question: https://stackoverflow.com/q/32333870
# answered by SO user Siyh: https://stackoverflow.com/a/35705477
def scale_bar(ax, location=(0.92, 0.95)):
    llx0, llx1, lly0, lly1 = ax.get_extent(ccrs.PlateCarree())
    sbllx = (llx1 + llx0) / 2
    sblly = lly0 + (lly1 - lly0) * location[1]

    tmc = ccrs.TransverseMercator(sbllx, sblly)
    x0, x1, y0, y1 = ax.get_extent(tmc)
    sbx = x0 + (x1 - x0) * location[0]
    sby = y0 + (y1 - y0) * location[1]

    plt.plot([sbx, sbx - 20000], [sby, sby], color='k', linewidth=9, transform=tmc)
    plt.plot([sbx, sbx - 10000], [sby, sby], color='k', linewidth=6, transform=tmc)
    plt.plot([sbx-10000, sbx - 20000], [sby, sby], color='w', linewidth=6, transform=tmc)

    plt.text(sbx, sby-4500, '20 km', transform=tmc, fontsize=8)
    plt.text(sbx-12500, sby-4500, '10 km', transform=tmc, fontsize=8)
    plt.text(sbx-24500, sby-4500, '0 km', transform=tmc, fontsize=8)

#loads lga vector outline polygon for central highlands, check row header and CRS
lga = gpd.read_file('data/tas_lga.shp')
print(lga.head())

#loads land vector polygons for tasmania, check row header and CRS
land = gpd.read_file('data/land_100k.shp')
print(land.head())

#loads water vector polygons for tasmania, check row header and CRS
water = gpd.read_file('data/water.shp')
print(water.head())

#loads roads vector lines for tasmania, check row header and CRS
roads = gpd.read_file('data/tas_roads.shp')
print(roads.head())

#loads boreholes vector points for tasmania, check row header and CRS
bhs = gpd.read_file('data/drill_eng_geo.shp')
print(bhs.head())

#checks crs of each layer
print(lga.crs)
print(land.crs)
print(water.crs)
print(roads.crs)
print(bhs.crs)

#changes projection to match layers
#https://epsg.io/20251-8398
lga = lga.to_crs(epsg=28355)
bhs = bhs.to_crs(epsg=28355)

#checks all crs match, returns true or false
lga.crs == land.crs == water.crs == roads.crs == bhs.crs

#creates a subset of tas lgas to get central highlands lga polygon only
#see https://geopandas.org/en/stable/gallery/plot_clip.html
#ch_lga = lga[lga["LGA_NAME"] == "Central Highlands Council"]

#clips all state wide vector layers to central highlands lga subset
#see https://geopandas.org/en/stable/docs/reference/api/geopandas.clip.html
land_clip = gpd.clip(land, ch_lga)
water_clip = gpd.clip(water, ch_lga)
roads_clip = gpd.clip(roads, ch_lga)
bhs_clip = gpd.clip(bhs, ch_lga)

#plots clipped vector layers to see how this worked
#see https://geopandas.org/en/stable/gallery/spatial_joins.html
land_clip.plot()
water_clip.plot()
roads_clip.plot()
bhs_clip.plot()

#spatially joins between clipped land and water layers, show table and check no. rows
join_lw = gpd.sjoin(land_clip, water_clip, how='inner', lsuffix='left', rsuffix='right')
print(join_lw.head())
len(join_lw)

#drops the index_right column in order to do second join (python wont allow multiple columns by same name)
join_lw.drop('index_right', axis=1, inplace=True)

#spatially joins bhs to landwater, check no of rows (460)
#join bhs to land water vector
join_lwbhs = gpd.sjoin(bhs_clip, join_lw, how="inner", op="within")
len(join_lwbhs)

#checks column index
join_lwbhs.columns

#drops unused columns to tidy table and better view data
join_lwbhs.drop(['Index_right', 'URL_LINK', 'WB_ID', 'SUBCAT_ID', 'WB_MAP', 'WB_INFO', 'PURPOSE', 'COMPANY', 'DRILL_TYPE'], axis=1, inplace=True)
print(join_lwbhs.head())

#runs some queries on landwaterbhs
#prints unique values in each column
print(join_lwbhs.nunique())

#names each rock type, geological age and count of bhs in each rock category in central highlands
print(join_lwbhs.groupby(['ROCK', 'GEO_AGE', 'NAME'])['LENGTH'].count())

#names each rock, geo age and sum of bhs depth in each rock category in central highlands
print(join_lwbhs.groupby(['ROCK', 'GEO_AGE', 'NAME'])['LENGTH'].sum())

#derives new data and inserts a column with area_km2 into lw
#https://pandas.pydata.org/docs/getting_started/intro_tutorials/05_add_columns.html
join_lw["AREA_KM2"] = join_lw["SHAPE_AREA"] / 1000000

#checks landform category areas; firstly groups data by class
#https://autogis-site.readthedocs.io/en/latest/notebooks/L2/01-geopandas-basics.html
grouped_landform = join_lw.groupby('LANDFORM')

# then iterates over the group
for key, group in grouped_landform:

#checks how many rows each group has:
    print('Landform:', key)
    print('Number of rows:', len(group), "\n")

#shows what area in km2 is covered by each land class
landform_area = grouped_landform.AREA_KM2.sum()
print(landform_area)

#checks rock category areas; firstly groups data by class
#https://autogis-site.readthedocs.io/en/latest/notebooks/L2/01-geopandas-basics.html
grouped_rock = join_lw.groupby('ROCK')

# then iterates over the group
for key, group in grouped_rock:

    # checks how many rows each group has:
    print('Rock:', key)
    print('Number of rows:', len(group), "\n")

#shows what area in km2 is covered by each rock type class
rock_area = grouped_rock.AREA_KM2.sum()
print(rock_area)


#Presentation
#creates a map view
myFig = plt.figure(figsize=(10, 10))

#defines my crs as UTM ref for Tasmania
myCRS = ccrs.UTM(55, southern_hemisphere=True)

#creates an axis on which to plot data
#https://scitools.org.uk/cartopy/docs/v0.15/_modules/cartopy/crs.html#UTM
ax = plt.axes(projection=ccrs.Mercator())

#assigns and adds western highlands lga polygon from subset
ch_lga_feature = ShapelyFeature(ch_lga['geometry'], myCRS, edgecolor='k', facecolor='w')
xmin, ymin, xmax, ymax = ch_lga.total_bounds
ax.add_feature(ch_lga_feature) # add the outline feature to the map.

#using the boundary of the shapefile features, zooms the map to our area of interest
ax.set_extent([xmin, xmax, ymin, ymax], crs=myCRS)

#plots rock types; firstly defining how many unique rock types there are (9)
num_rock = len(land_clip.ROCK.unique())
print('Number of unique features: {}'.format(num_rock))

#selects colors for the 9 individual rock polygons
rock_colors = ['r','lightcoral','deeppink','darkviolet','dodgerblue','yellow','orange','mediumblue','green',]

#drops any null values from rock column (i.e. if polygons with no names exist)
#https://stackoverflow.com/questions/44681776/ignoring-nan-in-a-dataframe
rock_names = land_clip['ROCK'].dropna().unique()
rock_names.sort()
rock_names

#adds the rock polygon colours to the map using the colors above by iterating over the unique values in the 'ROCK' field
#also defines features characteristics
for i, name in enumerate(rock_names):
    feat = ShapelyFeature(land_clip['geometry'][land_clipped['ROCK'] == name], myCRS,
                          edgecolor='k',
                          facecolor=rock_colors[i],
                          linewidth=1,
                          alpha=0.25)
    ax.add_feature(feat)

#myFig # shows the updated figure

#adds polygon and line vectors to map
water_feat = ShapelyFeature(water_clip['geometry'], myCRS,
                            edgecolor='mediumblue',
                            facecolor='mediumblue',
                            linewidth=2)
ax.add_feature(water_feat)

roads_feat = ShapelyFeature(roads_clip['geometry'], myCRS,
                            edgecolor='black',
                            linewidth=1.5)

ax.add_feature(roads_feat)

#assigns and plots point data handles using ax.plot()
bhs_handles = ax.plot(bhs_clip.geometry.x, bhs_clip.geometry.y, 'h', ms=8, c='r', transform=myCRS)

#details a legend to match the colours plotted above
#generates a list of handles for the rock type
rock_handles = generate_handles(land_clip.ROCK.unique(), rock_colors, alpha=0.25)

#generates water handle
water_handles = generate_handles(['Lakes'], ['mediumblue'])

#generates roads handle
roads_handles = [mlines.Line2D([], [], color='black')]

#enables rock type polygons to be added to legend and updates ROCK names for consistency
nice_names = [name.title() for name in rock_names]

#ax.legend() takes a list of handles and a list of labels corresponding to the objects you want to add to the legend
handles = rock_handles + bhs_handles + water_handles + roads_handles
labels = nice_names + ['Boreholes', 'Lakes', 'Roads']

#add legend
#place legend off the side of fig https://stackoverflow.com/questions/4700614/how-to-put-the-legend-outside-the-plot-in-matplotlib?newreg=300ab0ba0af340879f2d222287d21c2c
leg = ax.legend(handles, labels, title='Legend', title_fontsize=14,
                 fontsize=12, bbox_to_anchor=(1.04,0.7), loc='upper left', frameon=True, framealpha=1)
#add a title
ax.set_title('Geological strata and borehole locations in Central Higlands, Tasmania', fontsize=16)

#myFig # to show the updated figure




#add bh label text, plotting to coordinates in geometry columns
for i, row in bhs_clip.iterrows():
    x, y = row.geometry.x, row.geometry.y # get the x,y location for each bh
    plt.text(x, y, row['NAME'].title(), fontsize=8, transform=myCRS) # use plt.text to place a label at x,y

#add scale bar as defined in above function
scale_bar(ax)



# add geographic gridlines to map
gridlines = ax.gridlines(draw_labels=True,
                         xlocs=[146, 146.5, 147],
                         ylocs=[-42, -42.5])
gridlines.left_labels = True
gridlines.bottom_labels = True
ax.set_extent([xmin, xmax, ymin, ymax], crs=myCRS) # set the extent to the boundaries of the central highlands polygon

#save
myFig.savefig('tas_geo.png', bbox_inches='tight', dpi=300)